# Author: Derek Qi
# Date: 1/14/2017
# Version: 0.1

import numpy as np
import cvxopt as opt
from cvxopt import solvers, matrix, sparse, spmatrix
solvers.options['show_progress'] = False  # Turn off progress printing

def utility(weight, alpha, sigma, gamma, lambd):
    """
    Utility function with the simple Markowitz form.
    :param weight:
    :param alpha:
    :param sigma:
    :param gamma:
    :param lambd:
    :return:
    """
    temp = np.linalg.cholesky(sigma)
    htemp = np.dot(weight.T, temp)
    u = np.inner(alpha, weight) - gamma / 2 * np.dot(np.transpose(htemp), htemp)
    return u


def optimizer(alpha, sigma, gamma, lambd):
    """
    Optimizer given the projected alpha and sigma with a given utility function.
    :param alpha: numpy array, n-by-1, projected asset alpha
    :param sigma: numpy array, n-by-n, projected asset covariance matrix
    :param gamma: volatility preference coefficient
    :param lambd: absolute holdings coefficient
    :return: dictionary generated by cvxopt.qp function
    """
    alpha_m, sigma_m = matrix(alpha), matrix(sigma)
    N_INS = alpha_m.size[0]

    # Tool matices
    zero_m = matrix(0.0, (N_INS, N_INS))
    I = matrix(np.eye(N_INS))
    neg_I = - matrix(np.eye(N_INS))


    # define the function passed to solver of cvxopt
    # # Not needed if using qp
    # def obj_func(x=None, z=None):
    #     if not x:
    #         return 0, matrix(0.0, (2 * N_INS, 1))
    #     val = - utility(x, alpha, sigma, gamma, lambd=0) # function value, we want max utility so take the negative value
    #     Df = alpha_m + gamma * sigma_m * x # Gradient vector
    #     if not z:
    #         return val, Df
    #     H = matrix(0.0, (N_INS, N_INS))
    #     # Hessian need to be implemented after non-linear constraint is added
    #     return val, Df, H

    # define input variables
    q = matrix([-1 * alpha_m, matrix(lambd, (N_INS, 1))])
    P = matrix([[gamma * sigma_m, zero_m], [zero_m, zero_m]])

    # define the constraints
    # equalities
    # sum of all the weights equal to 1
    A = matrix([[matrix(1.0, (1, N_INS))], [matrix(0.0, (1, N_INS))]])
    b = opt.matrix(1.0)

    # inequalities
    G_lst = []
    h_lst = []

    # Constraints
    # G_lst.append( sparse([neg_I, matrix(0.0, (N_INS, N_INS))]).T )
    # h_lst.append( matrix(0.0, (2 * N_INS, 1)) )

    G_lst.append(matrix([I, neg_I]).T )
    h_lst.append(matrix(0.0, (N_INS, 1)) )

    G_lst.append(matrix([neg_I, neg_I]).T )
    h_lst.append(matrix(0.0, (N_INS, 1)) )

    G_lst.append(matrix([matrix(0.0, (N_INS, N_INS)), neg_I]).T )
    h_lst.append(matrix(0.0, (N_INS, 1)) )

    # Stacking together
    G = matrix([G for G in G_lst])
    h = matrix([h for h in h_lst])

    # solution = solvers.cp(obj_func, G, h, A, b, dims)['x']
    solution = solvers.qp(P, q, G, h, A, b)
    return solution

if __name__ == "__main__":
    np.random.seed(123)
    n_assets = 4
    n_obs = 1000

    ret_vec = np.random.randn(n_assets, n_obs)
    alpha = np.mean(ret_vec, axis=1)
    sigma = np.cov(ret_vec)

    w = np.random.rand(n_assets)
    w /= sum(w) # initial weights

    solution = optimizer(alpha, sigma, gamma=1, lambd=0.3)

    x_opt = np.array(solution['x'][:4])
    port_ret = np.dot(alpha, x_opt) # return of the optimized portfolio
    temp = np.dot(x_opt.T, np.linalg.cholesky(sigma))
    port_var = np.dot(temp, temp.T) # variance of the optimized portfolio
    sharpe = port_ret / port_var # simple sharpe ratio with 0 interest rate
    print('Sharpe ratio:', sharpe[0][0])



